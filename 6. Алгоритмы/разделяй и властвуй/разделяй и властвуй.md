Алгоритмы, основанные на парадигме «разделяй и властвуй», решают задачи путём их рекурсивного разбиения на более мелкие подзадачи, решения этих подзадач и последующего объединения результатов для получения окончательного решения. Ниже представлена сравнительная таблица некоторых распространённых алгоритмов, использующих этот подход:


| **Алгоритм**                                               | **Описание**                                                                                                                                                                                                                                                                                                                                                                                     | **Время выполнения** | **Пример кода на JavaScript**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Быстрая 
сортировка**                           | Разделяет массив, выбирая <br />опорный элемент, <br />и переставляет элементы так<br />, чтобы элементы меньше опорного<br /> оказались слева,<br /> а больше — справа; затем рекурсивно <br />применяется к полученным подмассивам. | O(n log n)                          | `javascript<br>function quickSort(arr)
 {<br> if (arr.length <= 1)
 return arr;<br> const pivot = arr[Math.floor(arr.length / 2)];
<br> const left = arr.filter(x => x < pivot);<br>
 const right = arr.filter(x => x > pivot);<br> return [...quickSort(left), pivot, ...quickSort(right)];<br>}<br>`                                                                                                                                                                                                                                                                      |
| **Сортировка
 слиянием**                         | Делит массив на две половины, <br />рекурсивно сортирует каждую, <br />а затем объединяет отсортированные <br />половины в один массив.                                                                                                                                                               | O(n log n)                          | `javascript<br>function mergeSort(arr) {<br> if (arr.length <= 1) return arr;<br> const mid = Math.floor(arr.length / 2);<br> const left = mergeSort(arr.slice(0, mid));<br> const right = mergeSort(arr.slice(mid));<br> return merge(left, right);<br>}<br><br>function merge(left, right) {<br> let result = [],<br> li = 0,<br> ri = 0;<br> while (li < left.length && ri < right.length) {<br> if (left[li] < right[ri]) result.push(left[li++]);<br> else result.push(right[ri++]);<br> }<br> return result.concat(left.slice(li)).concat(right.slice(ri));<br>}<br>` |
| **Быстрое 
преобразование 
Фурье (FFT)** | Разбивает вычисление дискретного<br /> преобразования Фурье <br />на более мелкие подзадачи, что <br />позволяет значительно <br />ускорить обработку сигналов.                                                                                                                   | O(n log n)                          | javascript<br>function fft(signal) <br />{<br> const N = signal.length;<br> <br />if (N <= 1) <br />return signal;<br> const even = fft(signal.filter((_, i) => i % 2 === 0));<br> const odd = fft(signal.filter((_, i) => i % 2 !== 0));<br> const T = [...Array(N / 2)].map((_, k) => Math.exp(-2 * Math.PI * 1j * k / N) * odd[k]);<br> return [...Array(N)].map((_, k) => even[k % (N / 2)] + T[k % (N / 2)]);<br>}<br>                                                                                                                                                 |

Эти алгоритмы демонстрируют эффективность подхода «разделяй и властвуй» в решении сложных задач путём их разбиения на более простые подзадачи.
