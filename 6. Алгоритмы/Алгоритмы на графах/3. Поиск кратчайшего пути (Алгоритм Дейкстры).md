Использует **очередь с приоритетами**, чтобы найти **самый короткий путь** от одной вершины ко всем другим.

✅ **Быстрый `O((V + E) log V)`, точный**
❌ **Не работает с отрицательными рёбрами**

>
> class PriorityQueue {
> constructor() { this.queue = []; }
> enqueue(node, priority) { this.queue.push({ node, priority }); this.queue.sort((a, b) => a.priority - b.priority); }
> dequeue() { return this.queue.shift().node; }
> }
>
> function dijkstra(graph, start) {
> let distances = {}, pq = new PriorityQueue();
> Object.keys(graph).forEach(node => distances[node] = Infinity);
> distances[start] = 0; pq.enqueue(start, 0);
>
> while (pq.queue.length) {
> let node = pq.dequeue();
> for (let neighbor in graph[node]) {
> let newDist = distances[node] + graph[node][neighbor];
> if (newDist < distances[neighbor]) {
> distances[neighbor] = newDist;
> pq.enqueue(neighbor, newDist);
> }
> }
> }
> return distances;
> }
>
> let weightedGraph = { A: { B: 4, C: 2 }, B: { A: 4, C: 5, D: 10 }, C: { A: 2, B: 5, D: 3 }, D: { B: 10, C: 3 } };
> console.log(dijkstra(weightedGraph, "A")); // { A: 0, B: 4, C: 2, D: 5 }
