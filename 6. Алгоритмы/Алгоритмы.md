**Алгоритмы со сложностью O(n)** — это такие, у которых время работы растёт пропорционально nn**n** (где nn**n** — размер входных данных). Ниже приведены некоторые классические примеры:

1. **Линейный поиск (Linear Search)**
   * **Суть**: последовательно проверяем каждый элемент массива (или списка), пока не найдём искомый (либо не переберём все элементы).
   * **Сложность**: O(n)O(n)**O**(**n**).
2. **Поиск минимума/максимума**
   * **Суть**: проходим по массиву один раз и запоминаем текущее минимальное/максимальное значение.
   * **Сложность**: O(n).
3. **Подсчёт суммы (или любого другого агрегата) элементов массива**
   * **Суть**: один проход по массиву, где при каждом шаге обновляется сумма.
   * **Сложность**: O(n).
4. **Слияние двух отсортированных списков**
   * **Суть**: берём элементы из начала каждого списка и сравниваем, добавляя в результирующий список тот, который меньше (или больше при обратном порядке). Движемся по обоим спискам без возврата назад.
   * **Сложность**: O(n+m), где n** и m** — размеры списков (суммарно тоже линейная).
5. **Обход в ширину (BFS) или в глубину (DFS) на графе с использованием списков смежности**
   * **Суть**: каждый узел и каждое ребро посещается ровно один раз (при условии использования списков смежности).
   * **Сложность**: O(V+E), где V — количество вершин, E — количество рёбер; если граф «разреженный» (E пропорционально V), получаем близко к O(n).
6. **Counting Sort (при ограниченном диапазоне значений)**
   * **Суть**: если значения элементов лежат в небольшом диапазоне, создаём вспомогательный массив для подсчёта количества вхождений каждого возможного значения, а затем формируем отсортированный массив.
   * **Сложность**: O(n+k), где k — размер диапазона. При k≪nk \\ll  можно считать почти O(n)



**Основная идея**: чтобы алгоритм был O(n), он не должен совершать вложенных операций пропорционально n (например, двойные циклы с n×n\times), а чаще всего выполняет один (или константное число) проход(ов) по входным данным.

Ниже приведены короткие реализации классических алгоритмов с линейной сложностью O(n)на JavaScript (ES6+).
Для примеров используем:

* `arr` — массив (или список) данных.
* `target` — искомое значение.
* `n` — размерность данных (чаще всего `arr.length`).

### Общая идея O(n) алгоритмов

Алгоритмы с временной сложностью O(n) делают **фиксированное (или ограниченное) количество операций на каждый элемент** входных данных. Это значит, что если в данных n элементов, то общее количество операций пропорционально n.

Такой подход характерен для:

* Одного или нескольких **линейных проходов** по массиву (без вложенных циклов на те же nn**n**).
* Чтения/записи элементов (или вершин/рёбер) **ровно по одному разу**.
* Отсутствия «взрывного роста» количества операций при увеличении размера входных данных как, например, в O(n2)
