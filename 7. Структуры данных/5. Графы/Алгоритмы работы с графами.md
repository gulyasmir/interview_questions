### ** Обход в глубину (DFS – Depth-First Search)**

**Ищет путь рекурсивно, углубляясь в одну ветку.**
Использует **стек (рекурсия)**.

```
function dfs(graph, node, visited = new Set()) {
  if (visited.has(node)) return;
  console.log(node);
  visited.add(node);
  for (let neighbor of graph[node]) {
    dfs(graph, neighbor, visited);
  }
}

let graph = {
  A: ["B", "C"],
  B: ["A", "D", "E"],
  C: ["A", "F"],
  D: ["B"],
  E: ["B", "F"],
  F: ["C", "E"]
};

dfs(graph, "A"); // A B D E F C

```

### ** Обход в ширину (BFS – Breadth-First Search)**

**Ищет путь уровнями (по слоям).**
Использует **очередь (FIFO)**.

```
function bfs(graph, start) {
  let queue = [start];
  let visited = new Set();
  
  while (queue.length) {
    let node = queue.shift();
    if (!visited.has(node)) {
      console.log(node);
      visited.add(node);
      queue.push(...graph[node]);
    }
  }
}

bfs(graph, "A"); // A B C D E F

```

### ** Поиск кратчайшего пути (Алгоритм Дейкстры)**

**Работает с взвешенными графами (минимальный путь от одной вершины до всех остальных).**
Использует **очередь с приоритетами (Heap).**

```
class PriorityQueue {
  constructor() {
    this.queue = [];
  }
  
  enqueue(item, priority) {
    this.queue.push({ item, priority });
    this.queue.sort((a, b) => a.priority - b.priority);
  }

  dequeue() {
    return this.queue.shift().item;
  }
}

function dijkstra(graph, start) {
  let distances = {};
  let pq = new PriorityQueue();

  for (let node in graph) {
    distances[node] = Infinity;
  }
  distances[start] = 0;
  pq.enqueue(start, 0);

  while (pq.queue.length) {
    let node = pq.dequeue();
    for (let neighbor in graph[node]) {
      let newDist = distances[node] + graph[node][neighbor];
      if (newDist < distances[neighbor]) {
        distances[neighbor] = newDist;
        pq.enqueue(neighbor, newDist);
      }
    }
  }
  return distances;
}

let weightedGraph = {
  A: { B: 4, C: 2 },
  B: { A: 4, C: 5, D: 10 },
  C: { A: 2, B: 5, D: 3 },
  D: { B: 10, C: 3 }
};

console.log(dijkstra(weightedGraph, "A")); // { A: 0, B: 4, C: 2, D: 5 }

```



**Плюс:** Оптимален для **поиска кратчайшего пути** в **взвешенных графах**.
❌ **Минус:** Медленный (`O(V²)`, с кучей `O((V + E) log V)`).

## **4. Где используются графы?**

✅ **Социальные сети** (Facebook, LinkedIn) – поиск друзей, рекомендации.
✅ **Навигация (Google Maps, GPS)** – поиск маршрутов.
✅ **Поиск в интернете (PageRank Google)** – анализ ссылок между сайтами.
✅ **Базы данных (графовые базы: Neo4j, ArangoDB)** – связи между данными.
✅ **Компиляторы (DAG)** – построение зависимостей между задачами.
✅ **Компьютерные сети (IP-маршрутизация)** – поиск оптимального маршрута.

#### 

** Итоговая таблица**


| Тип графа                      | Описание                        | Применение                           |
| -------------------------------------- | --------------------------------------- | ---------------------------------------------- |
| **Неориентированный** | Без направлений           | Социальные сети                  |
| **Ориентированный**     | Имеет направления       | Логистика, маршрутизация |
| **Взвешенный**               | У рёбер есть вес           | GPS-навигация                         |
| **DAG (ациклический)**     | Без циклов                     | Компиляторы, Git                    |
| **Матрица смежности**  | `O(1)`доступ,`O(n²)`память | Полносвязные графы            |
| **Список смежности**    | `O(V + E)`память                  | Разреженные графы              |

🚀 **Вывод:**

* Для **поиска в глубину** – `DFS`
* Для **поиска кратчайшего пути (невзвешенный)** – `BFS`
* Для **поиска кратчайшего пути (взвешенный)** – `Dijkstra`

**Графы – основа алгоритмов сетей, маршрутов, баз данных и ИИ!** 🔥
