**Двусвязная очередь — [абстрактный тип данных](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Абстрактный тип данных"), в котором элементы можно добавлять и удалять как в начало, так и в конец. Может быть реализована при помощи [двусвязного списка](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D1%83%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA).


* PushBack — добавление в конец очереди.
* PushFront — добавление в начало очереди.
* PopBack — выборка из конца очереди.
* PopFront — выборка из начала очереди.
* IsEmpty — проверка наличия элементов.
* Clear — очистка.

Двусвязная очередь

**Двусвязная очередь (Deque, Double-ended Queue)** – это структура данных, представляющая собой очередь, в которой элементы могут добавляться и удаляться как с начала, так и с конца.

### **Основные операции:**

* `push_front(value)` – добавление в начало
* `push_back(value)` – добавление в конец
* `pop_front()` – удаление из начала
* `pop_back()` – удаление из конца
* `front()` – доступ к первому элементу
* `back()` – доступ к последнему элементу
* `is_empty()` – проверка на пустоту

### **Применение:**

* Реализация очередей с приоритетом
* Алгоритмы поиска в ширину (BFS)
* Буферы и кэширование

Реализация может быть основана на **двусвязном списке** или **динамическом массиве**.

Реализация Deque на JavaScript

Этот **двусвязный Deque** поддерживает вставку и удаление с обеих сторон за **O(1)**

```
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }
}

class Deque {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    // Добавление в начало
    pushFront(value) {
        const newNode = new Node(value);
        if (!this.head) {
            this.head = this.tail = newNode;
        } else {
            newNode.next = this.head;
            this.head.prev = newNode;
            this.head = newNode;
        }
        this.size++;
    }

    // Добавление в конец
    pushBack(value) {
        const newNode = new Node(value);
        if (!this.tail) {
            this.head = this.tail = newNode;
        } else {
            newNode.prev = this.tail;
            this.tail.next = newNode;
            this.tail = newNode;
        }
        this.size++;
    }

    // Удаление с начала
    popFront() {
        if (!this.head) return null;
        const value = this.head.value;
        this.head = this.head.next;
        if (this.head) {
            this.head.prev = null;
        } else {
            this.tail = null;
        }
        this.size--;
        return value;
    }

    // Удаление с конца
    popBack() {
        if (!this.tail) return null;
        const value = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
            this.tail.next = null;
        } else {
            this.head = null;
        }
        this.size--;
        return value;
    }

    // Получение первого элемента
    front() {
        return this.head ? this.head.value : null;
    }

    // Получение последнего элемента
    back() {
        return this.tail ? this.tail.value : null;
    }

    // Проверка на пустоту
    isEmpty() {
        return this.size === 0;
    }

    // Получение размера очереди
    getSize() {
        return this.size;
    }

    // Вывод всех элементов (для отладки)
    print() {
        let current = this.head;
        let result = [];
        while (current) {
            result.push(current.value);
            current = current.next;
        }
   

```
