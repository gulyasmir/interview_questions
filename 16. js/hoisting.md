В JavaScript термин "hoisting" (поднятие) описывает поведение, при котором объявления переменных, функций и классов перемещаются интерпретатором к началу их области видимости перед выполнением кода. Это означает, что вы можете использовать функции и переменные до их фактического объявления в коде.

[developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting?utm_source=chatgpt.com)

### **Поднятие функций:**

Функции, объявленные с помощью деклараций (`function`), полностью поднимаются вместе с их определениями. Это позволяет вызывать функцию до ее объявления в коде:

```
console.log(greet()); // "Привет!"

function greet() {
  return "Привет!";
}

```

В этом примере функция `greet` вызывается до ее объявления, но благодаря поднятию код работает корректно.

### **Поднятие переменных:*

Переменные, объявленные с помощью `var`, поднимаются, но их инициализация остается на месте. До инициализации такие переменные имеют значение `undefined`:*

```
console.log(name); // undefined

var name = "Алиса";
console.log(name); // "Алиса"

```

Здесь объявление `var name` поднимается вверх области видимости, но присвоение значения происходит в строке, где оно указано. Поэтому первый `console.log` выводит `undefined`.

Переменные, объявленные с помощью `let` и `const`, также поднимаются, но находятся в так называемой "временной мертвой зоне" (temporal dead zone) до их фактического объявления. Попытка доступа к таким переменным до объявления приводит к ошибке:

```
console.log(age); // ReferenceError: Cannot access 'age' before initializationlet age = 25;
```

Таким образом, хотя объявление `let age` поднимается, доступ к переменной до ее инициализации невозможен.


```let
let age;
console.log(age);
age = 25;

// undefined
```

### **Поднятие классов:**

Классы, объявленные с помощью `class`, поднимаются аналогично `let` и `const`. Попытка использовать класс до его объявления приводит к ошибке:

```
const cat = new Animal(); // ReferenceError: Cannot access 'Animal' before initialization

class Animal {
  constructor(name) {
    this.name = name;
  }
}

```

В этом примере попытка создать экземпляр класса `Animal` до его объявления вызывает ошибку.

Понимание механизма поднятия важно для предотвращения неожиданных ошибок и написания предсказуемого кода. Рекомендуется всегда объявлять переменные и функции перед их использованием, чтобы избежать потенциальных проблем, связанных с поднятием.
