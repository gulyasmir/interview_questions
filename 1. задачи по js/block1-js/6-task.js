function makeGroup() {
    let people = [];
    let i = 0;
    while(i < 5) {
        let man = function () {
            console.log(i);
        }

        people.push(man);
        i++;
    }
    return people;
}
let group = makeGroup();
group[0]();
group[4]();
// 5
// 5

/*

Итог:
Функция использует i из своей внешней области видимости.
Замыкание запоминает не значение i, а ссылку на i.
Поэтому все функции показывают 5, а не 0, 1, 2, 3, 4.
Чтобы исправить это, нужно использовать let в for или IIFE.


В коде есть переменная i, объявленная вне функции, в makeGroup():
let i = 0;

В while-цикле создаются функции:
 let man = function () {
            console.log(i);
        }
        
Эта функция не получает i как аргумент.
Вместо этого она использует переменную i из своей внешней области видимости.
Замыкание:

man не фиксирует значение i в момент своего создания.
Вместо этого она запоминает ссылку на i, который живёт в makeGroup().
Когда потом group[0]() вызывается, он использует текущее значение i, а оно уже равно 5.

Почему не undefined?
1. Переменная i существует в области видимости
i была объявлена в makeGroup() с let, и она остаётся доступной, пока makeGroup() не завершится.
После выхода из makeGroup() переменная не уничтожается, потому что на неё ссылаются функции в массиве people.

2. Замыкание держит ссылку на i, а не фиксирует её значение
Код console.log(i); не запоминает значение i в момент создания функции.
Вместо этого он использует переменную i по ссылке.

3. Когда функции вызываются, i === 5
Цикл while завершился, i увеличилось до 5.
Теперь все функции, которые мы добавили в people, будут использовать это значение i.
*/

// Как сделать так, чтобы каждая функция запомнила своё значение i ?
// 1. Использовать let i внутри for-цикла:
//  В for (let i = 0; i < 5; i++) переменная i создаётся заново на каждой итерации, и каждая функция получает своё значение i.
function makeGroup() {
    let people = [];
    for (let i = 0; i < 5; i++) {
        people.push(function() {
            console.log(i);
        });
    }
    return people;
}
let group1 = makeGroup();
group1[0](); // 0
group1[4](); // 4


// 2. Использовать замыкание через IIFE (немедленно вызываемая функция):
//  Здесь i передаётся в IIFE ((function(i) {...})(i)), создавая новую копию i для каждой функции.
function makeGroup() {
    let people = [];
    let i = 0;
    while (i < 5) {
        (function(i) {
            people.push(function() {
                console.log(i);
            });
        })(i);
        i++;
    }
    return people;
}
let group2 = makeGroup();
group2[0](); // 0
group2[4](); // 4
