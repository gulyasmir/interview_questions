При выборе индекса для составного ключа в базе данных важно учитывать несколько критериев, чтобы индекс эффективно ускорял запросы и минимизировал накладные расходы. Основные критерии:

### **1. Порядок столбцов в индексе**

* Столбцы в индексе должны соответствовать порядку, в котором они чаще всего используются в условиях `WHERE`, `ORDER BY` и `GROUP BY`.
* Если запросы фильтруются по нескольким столбцам, ставьте в начало индексируемых полей те, которые обладают **более высокой селективностью** (имеют больше уникальных значений).

### **2. Селективность столбцов**

* Чем выше селективность, тем эффективнее индекс. Селективность — это отношение уникальных значений к общему количеству строк.
* Например, индекс `(country, city, street)` эффективен, если `country` и `city` имеют много разных значений.

### **3. Частота использования в фильтрации (`WHERE`)**

* Индекс должен включать столбцы, которые чаще всего используются в `WHERE`, `JOIN`, `ORDER BY` и `GROUP BY`.
* Если столбец редко участвует в фильтрации, но всегда запрашивается, лучше добавить его в `INCLUDE` (в PostgreSQL `COVERING INDEX`).

### **4. Поддержка диапазонных условий (`BETWEEN`, `>`, `<`)**

* Индекс будет работать эффективно, если диапазонные фильтры (`BETWEEN`, `>`, `<`) применяются только к **последнему столбцу** в индексе.
* Например, индекс `(A, B, C)` эффективен для запроса `WHERE A = ? AND B = ? AND C BETWEEN ? AND ?`, но неэффективен, если `B` используется в `BETWEEN`, а `C` в фильтрации.

### **5. Поддержка сортировки (`ORDER BY`)**

* Если запрос использует `ORDER BY`, составной индекс должен соответствовать порядку сортировки.
* Например, индекс `(created_at, status)` ускорит `ORDER BY created_at, status`, но не поможет при `ORDER BY status, created_at`.

### **6. Использование в JOIN**

* Если таблицы соединяются по нескольким столбцам, индекс должен содержать ключи соединения (`ON table1.col1 = table2.col1 AND table1.col2 = table2.col2`).

### **7. Покрывающий индекс**

* Если индекс содержит все столбцы, которые используются в `SELECT`, он становится **покрывающим (covering index)**, уменьшая обращения к основным данным.
* Например, `INDEX (user_id, order_date, total_price)` покрывает `SELECT order_date, total_price FROM orders WHERE user_id = ?`.

### **8. Баланс между индексами и производительностью записи**

* Чем больше индексов в таблице, тем медленнее будут операции `INSERT`, `UPDATE`, `DELETE`, так как индексы тоже нужно обновлять.
* Избегайте избыточных индексов, которые не используются в запросах.
