// Асинхронный ретрай с типизацией

async function retry<T>(fn: () => Promise<T>, retries: number): Promise<T> {
    while (retries > 0) {
      try {
        return await fn(); // Успешный результат возвращается
      } catch (error) {
        retries--; // Уменьшаем счётчик попыток
        if (retries === 0) {
          throw error; // Если попытки исчерпаны, выбрасываем последнюю ошибку
        }
      }
    }
  
    // Этот return никогда не будет вызван, так как throw завершает функцию
    throw new Error("Unreachable code");
  }
  
  // Пример использования
  let counter = 0;
  const unreliableFn = async () => {
    if (++counter < 3) throw new Error("Failed");
    return "Success";
  };
  
  retry(unreliableFn, 5)
    .then((result) => console.log(result)) // "Success"
    .catch((error) => console.error(error.message));
  
  /* Функция retry повторяет вызов асинхронной функции до заданного числа попыток.
Если функция завершилась успешно, результат возвращается.
Если все попытки завершились с ошибкой, последняя ошибка выбрасывается.
Этот подход полезен для повторных вызовов ненадёжных API или работы с нестабильными сетевыми соединениями.
Тип T гарантирует, что результат вызова будет правильно типизирован.

  Обработка ошибок:
Если fn() выбрасывает ошибку, её обрабатывает блок catch.
Если попытки закончились (retries === 0), ошибка явно выбрасывается с помощью throw.

Явный возврат значения:

Если fn() завершится успешно, результат возвращается через return await fn().

Удаление undefined:

TypeScript больше не предполагает, что функция может вернуть undefined, потому что все пути выполнения либо возвращают результат, либо выбрасывают ошибку.

Функция корректно обрабатывает все случаи: успешное выполнение, ошибки и исчерпание попыток.
TypeScript больше не выдаёт предупреждений, так как все пути выполнения функции возвращают значение или выбрасывают ошибку.


Как работает пример

Первая попытка:

unreliableFn выбрасывает ошибку, так как counter < 3.
Ошибка обрабатывается в catch, и количество оставшихся попыток уменьшается.

Третья попытка:

Когда counter достигает 3, unreliableFn возвращает "Success".
Результат возвращается из функции retry.

Если попытки исчерпаны:

Если unreliableFn выбрасывает ошибку на всех попытках, последняя ошибка передаётся наружу через throw.
Таким образом, это надёжное и безопасное решение.
*/